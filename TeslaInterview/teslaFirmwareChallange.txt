#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
 
 
////////////////////////////////////////////////////////////////////////////////
/* TESLA MOTORS FIRMWARE TEST
 * You have 120 minutes to complete the test. There are 100 points total.
 *
 * All solutions should compile in Coderpad.io without error or warnings
 *
 * Penalties:
 * -1 / minute over time
 * -3 for 1 or more compilation errors
 * -2 for 1 or more compilation warnings
 *
 * Do not use outside aid or share the content of this test
 *
 * A main() function is provided at the bottom for your use
 */
////////////////////////////////////////////////////////////////////////////////
 
////////////////////////////////////////////////////////////////////////////////
// 1) Macro (10 points)
//    Create a macro (named C_TO_F) to convert from degrees Celsius to Fahrenheit
//    Macro should work for integer or floating point types
//    Note: degF = degC * (9/5) + 32
#define C_TO_F(F) ((F)*(9.0/5.0)+32)

 
 
////////////////////////////////////////////////////////////////////////////////
// 2) Bit Manipulation (5 points)
//    Write a function that inverts (0 -> 1 or 1 -> 0) the most significant and
//    least significant bits of the data value pointed to by b.
 
void flip_hi_lo(uint8_t* b)
{
    uint8_t mask = 0x81;
    *b = (*b)^mask;
}
 
////////////////////////////////////////////////////////////////////////////////
// 3) Debugging (5 points)
//    The function computeSquareADC() has not been producing correct
//    output consistently. Please describe all issues with the function.

// ADC_RESULT is volatile, meaning it can change at any time without the program knowing, in this case it seems like it would be changing from an ADC periphrial. Thus, ADC_RESULT * ADC_RESULT may read 2 different values, instead you should read this value once and store it as a uint8_t, then do the multiplication with itself. Furthermore, this function should return a 16 bit integer (rather than 8) as returning on 8 bits will result in the most significant byte being cut off, so any overflow from the 8 bit multiplication will be lost.
 
volatile uint8_t ADC_RESULT;
uint8_t computeSquareADC(void)
{
    uint16_t retval = ADC_RESULT * ADC_RESULT;
    return retval;
}

// Better implementation
uint16_t computeSquareADCBetter(void) {
    uint8_t readVal = ADC_RESULT;
    uint16_t retVal = readVal * readVal;
    return retVal;
}

 
////////////////////////////////////////////////////////////////////////////////
// 4) Memory dump (10 points)
//    The following memory dump was taken while debugging an issue.
//
// Memory Dump:
// Address:  Byte:
// 0x1000    0xA0
// 0x1001    0x0A
// 0x1002    0xBA
// 0x1003    0x48
// 0x1004    0x2C
// 0x1005    0xB7
// 0x1006    0x3B
// 0x1007    0x82
// 0x1008    0x9C
// 0x1009    0xE5
// 0x100A    0x17
// 0x100B    0x40
// 0x100C    0xEF
// 0x100D    0x47
// 0x100E    0x0F
// 0x100F    0x98
// 0x101:q
    0x6F // 32 byte aligned
// 0x1011    0xD5  
// 0x1012    0x70
// 0x1013    0x9E 
// 0x1014    0x94 // 32 aligned
// 0x1015    0x99
// 0x1016    0x4A
// 0x1017    0xBA
// 0x1018    0xCA // 32 aligned
// 0x1019    0xB2
// 0x101A    0x32
// 0x101B    0xE6
// 0x101C    0x8E
// 0x101D    0xB9
// 0x101E    0xC5
// 0x101F    0x2E
// 0x1020    0xC3
//
// System is 32-bit, little-endian.
// A variable called myPacket is of type packet_S (typedef below).
// (Default compiler options; unpacked, naturally aligned.)
// The address of myPacket is 0x1010.
//
typedef struct
{
    uint8_t count;
    uint16_t data[2];
    uint32_t timestamp;
} packet_S;
 
// a) What are the values of each member of myPacket?
// count = 0x6F
// data[0] = 0x9E70
// data[1] = 0x9994
// timestamp = 0xE632B2CA
 
// b) If the system was big-endian, what would the values of each member of
//    myPacket be?
// count = 0x6F
// data[0] = 0x709E
// data[1] = 0x9499
// timestamp = 0xCAB232E6 

 
////////////////////////////////////////////////////////////////////////////////
// 5) State Machine (20 points)
//
//    Complete the function below to implement the state machine shown in the
//    diagram below for an electronic gumball vending machine.
//     * The initial state of the state machine should be IDLE
//     * The function should output the current state of the state machine
//     * Unexpected or invalid input should not cause a state transition
//     * GENERIC_FAULT may be received in any state and should put the machine
//       into the FAULT state
//
//
//          COIN      +---------+
//   +--------------->|         |   BUTTON
//   |                |  READY  | ---------+       
//   |    COIN_RETURN |         |          |
//   |   +----------- +---------+          |
//   |   |                                 |
//   |   V                                 V
// +---------+                        +---------+
// |         |     VEND_COMPLETE      |         |
// |  IDLE   |<-----------------------| VENDING |
// |         |                        |         |
// +---------+                        +---------+
//
//                                 +---------+
//                                 |         |
//                GENERIC_FAULT    |  FAULT  |
//             +------------------>|         |
//                                 +---------+
//
 
typedef enum
{
    IDLE,
    READY,
    VENDING,
    FAULT
} state_E;
 
typedef enum
{
    COIN,
    COIN_RETURN,
    BUTTON,
    VEND_COMPLETE,
    GENERIC_FAULT
} input_E;
 
state_E stateMachine(input_E input)
{
    static state_E state;
    
    switch(state) {
        case IDLE:
            switch(input) {
                case COIN:
                    state = READY;
                    break;
                case GENERIC_FAULT:
                    state = FAULT;
                    break;
                default:
                    break;
            }
            break;
        case READY:
            switch(input) {
                case COIN_RETURN:
                    state = IDLE;
                    break;
                case BUTTON:
                    state = VENDING;
                    break;
                case GENERIC_FAULT:
                    state = FAULT;
                    break;
                default: 
                    break;
            }
            break;
        case VENDING:
            switch(input) {
                case VEND_COMPLETE:
                    state = IDLE;
                    break;
                case GENERIC_FAULT:
                    state = FAULT;
                    break;
                default:
                    break;
            }
            break;
        case FAULT:
            break;
    }
    return state;
}
 
 
////////////////////////////////////////////////////////////////////////////////
// 6) Unit Testing (10 points)
//    Write a unit test for validatePointerAndData that exercises all code paths
//    and branch conditions
 
// @param dataPtr - int32_t pointer to data to be used
//
// @return TRUE if pointer is non-NULL, data value is positive, non-zero and not
//         equal to the sentinel value 0x7FFFFFFF, FALSE otherwise
//
bool validatePointerAndData(int32_t* dataPtr)
{
    bool status = false;
    if ((dataPtr != NULL) &&
        (*dataPtr > 0)    &&
        (*dataPtr != 0x7FFFFFFF))
    {
        status = true;
    }
    return status;
}
 
//
// @return TRUE if all tests pass, FALSE otherwise
//
bool test_validatePointerAndData(void)
{ 
    bool pass = true;
    int32_t val;
    int32_t* p;
    
    // Should be false if NULL
    p = NULL;
    pass = pass && (validatePointerAndData(p) == false);
    
    // Should be false if negitive
    val = -1123;
    p = &val;
    pass = pass && (validatePointerAndData(p) == false);
    
    // Should return false if sentinel value
    val = 0x7FFFFFFF;
    pass = pass && (validatePointerAndData(p) == false);
    
    // Should return true is positive
    val = 123;
    pass = pass && (validatePointerAndData(p) == true);
    
    // Should return false if zero
    val = 0;
    pass = pass && (validatePointerAndData(p) == false);
        
    return pass;
}
 
 
////////////////////////////////////////////////////////////////////////////////
// 7) Low Pass Filter (10 points)
//    Implement a function that will be called at 10hz (every 100 ms) and returns
//    an exponentially weighted average. The latest sample is given 1/10 weighting
//    and previous filtered value a weighting of 9/10. The function should
//    initialize the filter to the first sample value received if it is the first
//    time the function has run.
 

float lowPassSamples_10hz(float sample)
{
    static float weightedAvg;
    static bool initialized = false;
    
    if(!initialized) {
        weightedAvg = sample;
        initialized = true;
    } else {
        weightedAvg = 1.0/10.0*sample + 9.0/10.0*weightedAvg; 
    }
    return weightedAvg;
}
 
////////////////////////////////////////////////////////////////////////////////
// 8a) Buffer (20 points: 8a + 8b)
//     Create a function to push a char into a FIFO. The FIFO should be implemented
//     as a circular buffer of length 20. The FIFO will be used to cache the most
//     recent data from a data stream, therefore, drop the oldest value if the
//     buffer is full.
 
#define BUFFER_SIZE 20U
char fifoBuffer[BUFFER_SIZE];
int front = 0;
int back = 0;
int size = 0;

void bufferPush_ISR(char data)
{
    // disableInterrupts() here
    fifoBuffer[front] = data;
    
    if(front == back && size == BUFFER_SIZE) {
        back += 1;
    } else {
        size += 1;
    }
    
    front += 1;
    
    if(front == BUFFER_SIZE) {
        front = 0;
    }
    
    if(back == BUFFER_SIZE) {
        back = 0;
    }

    // enableInterrupts() here
}
 
////////////////////////////////////////////////////////////////////////////////
// 8b) Create a function to print out and empty the data buffer.
//     Data should be printed in order from oldest to newest, active elements only.
 
void printAndEmptyBuffer(void)
{
    if(size == 0) {
        return;
    }
    
    
    do {
        // disableInterrupts() here
        printf("%c ", fifoBuffer[back]);
        
        back += 1;
        size -= 1;
        
        if(back == BUFFER_SIZE) {
            back = 0;
        }
        // enableInterrupts() here
    } while(size != 0);
    
}
 
////////////////////////////////////////////////////////////////////////////////
// 8c) Interrupts (10 points)
//     The function bufferPush_ISR() will be called from an interrupt service
//     routine whenever new data is available to be buffered.
//     The function printAndEmptyBuffer() will be called from a periodic task.
//     The functions disableInterrupts() and enableInterrupts() are available
//     for disabling and enabling interrupts, respectively.
//
//     In your implementations of bufferPush_ISR() and printAndEmptyBuffer(),
//     determine whether or not it is necessary to disable/enable interrupts.
//     If so, add comments where the calls are necessary. If not required,
//     briefly comment why not.
//

// bufferPush_ISR should disable interupts before interacting with the buffer and re-enable them after, this is becuase it is possible (archatecture depening) that the same ISR gets called in the middle of bufferPush_ISR. This should be an atomic call to avoid errors in the head and tail fifo indecies which could break the buffer.

// printAndEmptyBuffer should disable and enable interrupts as it is possible that an ISR calls bufferPush_ISR during execution, changing the data within the buffer, or worse interupting execution between setting the back and size parameters of the fifo casuing the buffer to break. Thus, it is similarly important that this is an atomic call. Interupts at the very least should be disabled within each loop iteration to make the setting size and back index atomic. It is possible (implementation depending) that instead you would want to disable/enable at the very beginning and end of the function call if you don't want to data to change during the reading process, but at a minimum they should be placed where I have indicated with comments in the function.



 

 
int main()
{
    printf("%f\n\n", C_TO_F(10.5));
    
    uint8_t b = 0xF2;
    flip_hi_lo(&b);
    printf("%d\n\n", b);
    
    state_E s;
    s = stateMachine(COIN);
    printf("%d\n", s);
    s = stateMachine(BUTTON);
    printf("%d\n", s);
    s = stateMachine(VEND_COMPLETE);
    printf("%d\n", s);
    s = stateMachine(VEND_COMPLETE);
    printf("%d\n", s);
    s = stateMachine(GENERIC_FAULT);
    printf("%d\n\n", s);
    
    bool pass = test_validatePointerAndData();
    printf("%d\n\n", pass);
    
    float w = lowPassSamples_10hz(10);
    w = lowPassSamples_10hz(1);
    w = lowPassSamples_10hz(200.5);
    printf("%f\n\n", w);
    
    
    bufferPush_ISR('a');
    bufferPush_ISR('b');
    bufferPush_ISR('c');
    bufferPush_ISR('d');
    bufferPush_ISR('e');
    bufferPush_ISR('f');
    bufferPush_ISR('g');

    printAndEmptyBuffer();
    
    return 0;
}=: